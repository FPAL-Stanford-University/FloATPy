import glob
import numpy

import matplotlib
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

from base_reader import BaseReader

class WchrAsciiReader(BaseReader):
    """
    Class to read in parallel ASCII data generated by the WCHR Regent code.
    """
    
    def __init__(self, filename_prefix):
        """
        Constructor of the WCHR reader class.
        """
        
        self.filename_prefix = filename_prefix
        self.coord_files = glob.glob(filename_prefix + 'coords_*.dat')
        
        files = glob.glob(filename_prefix + '[0-9]*.dat')
        
        self._steps = steps = []
        self.prow  = 0
        self.pcol  = 0
        for f in files:
            step = int(f[len(filename_prefix):len(filename_prefix)+4])
            if not (step in steps):
                steps.append(step)
            
            st  = f[len(filename_prefix):]
            ind = st.find('px')
            row = int(st[ind+2:ind+6])
            if row > self.prow:
                self.prow = row
            ind = st.find('pz')
            col = int(st[ind+2:ind+6])
            if col > self.pcol:
                self.pcol = col
        
        self.prow += 1
        self.pcol += 1
        
        # Set the lowest and highest global index of processor in x and z directions respectively.
        
        self.pencil_lo    = numpy.zeros((self.prow,self.pcol,2), dtype=int)
        self.pencil_hi    = numpy.zeros((self.prow,self.pcol,2), dtype=int)
        
        # Set the domain size in x, y and z directions respectively.
        self._domain_size = numpy.zeros(3, dtype=int)  
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                
                f = open(coordfile)
                
                line = f.readline().split()
                self.pencil_lo[row,col,0] = int(line[0])
                self.pencil_lo[row,col,1] = int(line[2])
                
                line = f.readline().split()
                self.pencil_hi[row,col,0] = int(line[0]) + 1
                self.pencil_hi[row,col,1] = int(line[2]) + 1
                
                if self._domain_size[1] == 0:
                    self._domain_size[1] = int(line[1]) + 1
                
                assert (self._domain_size[1] == (int(line[1]) + 1)), \
                    "Data is invalid. Unequal domain sized in the y direction for different pencils!"
                
                f.close()
        
        self._domain_size[0] = self.pencil_hi[-1,-1,0]
        self._domain_size[2] = self.pencil_hi[-1,-1,1]
        
        # Set indices for each variable.
        self.inds = {'rho' : 0, 'u' : 1, 'v' : 2, 'w' : 3, 'p' : 4}
        
        # Step is set to 0 by default.
        self._step = 0
    
    
    def setStep(self, step):
        """
        Update the metadata from the summary file in the data directory at a new time step.
        """
        
        assert (step in self._steps), "Step to read in is not available in the dataset."
        self._step = step
    
    
    def getStep(self):
        return self._step
    
    
    step = property(getStep, setStep)
    
    
    def setSubDomain(self, lo_and_hi):
        """
        Set the sub-domain for reading coordinates and data.
        """
        
        # Check if lo and hi are within the domain bounds first!!!
        
        try:
            lo, hi = lo_and_hi
        except ValueError:
            raise ValueError("Pass an iterable with two items!")
        
        for i in range(3):
            if lo[i] < 0 or lo[i] > self._domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size!')
            if hi[i] < 0 or hi[i] > self._domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size!')
            if hi[i] < lo[i]:
                raise ValueError('Invalid indices in chunk. Upper bound cannot be smaller than lower bound!')

        # Now set the chunk to be used later.
        self.chunk = ((lo[0],hi[0]),(lo[1],hi[1]),(lo[2],hi[2]))
    
    
    def getSubDomain(self):
        """
        Return two tuples containing the sub-domain used in this reader
        as a lower bound (lo) and upper bound (hi).
        """
        
        lo = (self.chunk[0][0], self.chunk[1][0], self.chunk[2][0])
        hi = (self.chunk[0][1], self.chunk[1][1], self.chunk[2][1])
        
        return lo, hi
    
    
    sub_domain = property(getSubDomain, setSubDomain)
    
    
    @property
    def domain_size(self):
        """
        Return a tuple containing the full domain size of this dataset.
        """
        
        return tuple(self._domain_size)
    
    
    @property
    def periodic_dimensions(self):
        """
        Return a tuple indicating if data is periodic in each dimension.
        """
        
        return (True, True, True)
    
    
    @property
    def time(self):
        """
        Return the simulation time at current time step.
        """
        
        return 0.
    
    
    @property
    def steps(self):
        """
        Return all of the steps.
        """
        
        return self._steps
    
    
    def readCoordinatesInX(self):
        """
        Method to read in the full domain's coordinates in x direction.
        """
        
        self.x_c = numpy.zeros((self._domain_size[0], self._domain_size[1], self._domain_size[2] ))
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                
                this_x = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,))
                
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.x_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_x.reshape((hi[0]-lo[0], self._domain_size[1], hi[1]-lo[1]), \
                                                                       order='F')
        
        if self._domain_size[0] > 1:
            self.dx = self.x_c[1,0,0] - self.x_c[0,0,0]
        else:
            self.dx = 1.
    
    
    def readCoordinatesInY(self):
        """
        Method to read in the full domain's coordinates in y direction.
        """
        
        self.y_c = numpy.zeros((self._domain_size[0], self._domain_size[1], self._domain_size[2] ))
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                
                this_y = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(1,))
                
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.y_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_y.reshape((hi[0]-lo[0], self._domain_size[1], hi[1]-lo[1]), \
                                                                       order='F')
        
        if self._domain_size[1] > 1:
            self.dy = self.y_c[0,1,0] - self.y_c[0,0,0]
        else:
            self.dy = 1.
    
    
    def readCoordinatesInZ(self):
        """
        Method to read in the full domain's coordinates in z direction.
        """
        
        self.z_c = numpy.zeros((self._domain_size[0], self._domain_size[1], self._domain_size[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(2,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.z_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_z.reshape((hi[0]-lo[0], self._domain_size[1], hi[1]-lo[1]), \
                                                                       order='F')
        
        if self._domain_size[2] > 1:
            self.dz = self.z_c[0,0,1] - self.z_c[0,0,0]
        else:
            self.dz = 1.
    
    
    def readCoordinates(self):
        """
        Method to read in the X, Y and Z coordinates of a chunk of index values.
        """
        
        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        x_c = numpy.zeros( chunk_size )
        y_c = numpy.zeros( chunk_size )
        z_c = numpy.zeros( chunk_size )
        
        ny = self._domain_size[1]
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                
                # Skip this proc if it's lowest dimension is higher than max of chunk.
                
                if ( lo[0] >= self.chunk[0][1] or 0 >= self.chunk[1][1] or lo[1] >= self.chunk[2][1] ):
                    continue
                if ( hi[0] <  self.chunk[0][0] or ny < self.chunk[1][0] or hi[1] <  self.chunk[2][0] ):
                    continue

                # Read in proc's data if there is an overlap.
                
                this_x, this_y, this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,1,2))
                this_x = this_x.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_y = this_y.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_z = this_z.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')

                # Copy data into chunk arrays.
                
                x_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_x[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

                y_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_y[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

                z_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_z[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

        return x_c, y_c, z_c
    
    
    def readData(self, var_names):
        """
        Method to read in the a chunk of the data for variables at current vizdump step.
        """
        
        # If a simple string is passed in, convert to a tuple.
        if isinstance(var_names, basestring):
            var_names = (var_names,)
        
        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        data = [ numpy.zeros( chunk_size ) for i in range(len(var_names)) ]
        
        ny = self._domain_size[1]
        
        for i in range(len(var_names)):
            var = var_names[i]
            v   = data[i]
            
            ind = self.inds[var]
            
            for row in range(self.prow):
                for col in range(self.pcol):
                    filename = self.filename_prefix + ('%04d_px%04d_pz%04d.dat' % (self._step, row, col))
                    lo = self.pencil_lo[row,col]
                    hi = self.pencil_hi[row,col]
                    
                    # Skip this proc if it's lowest dimension is higher than max of chunk.
                    
                    if ( lo[0] >= self.chunk[0][1] or 0 >= self.chunk[1][1] or lo[1] >= self.chunk[2][1] ):
                        continue
                    if ( hi[0] <  self.chunk[0][0] or ny < self.chunk[1][0] or hi[1] <  self.chunk[2][0] ):
                        continue
                    
                    # Read in processor's data if there is an overlap.
                    
                    this_var = numpy.loadtxt(filename, skiprows=2, unpack=True, usecols=(ind,))
                    this_var = this_var.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                
                    # Copy data into chunk arrays.
                    
                    v[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                       max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                       max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                    this_var[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                              max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                              max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]
        
        return tuple(data)
    
    
    def plotThreeSlice(self, var, index):
        """
        Method to plot variable var on three orthogonal slices intersecting at the given index.
        """
        
        xind = index[0]
        yind = index[1]
        zind = index[2]

        norm = matplotlib.colors.Normalize(vmin=var.min(), vmax=var.max())
        cmap = cm.ScalarMappable(norm=norm, cmap=cm.viridis)
        cmap.set_array(var)

        fig = plt.figure()
        ax = fig.gca(projection='3d')

        surf_x = ax.plot_surface(self.x_c[xind,:,:], self.y_c[xind,:,:], self.z_c[xind,:,:], \
                                 facecolors=cmap.to_rgba(var[xind,:,:]), linewidth=0)
        surf_y = ax.plot_surface(self.x_c[:,yind,:], self.y_c[:,yind,:], self.z_c[:,yind,:], \
                                 facecolors=cmap.to_rgba(var[:,yind,:]), linewidth=0)
        surf_z = ax.plot_surface(self.x_c[:,:,zind], self.y_c[:,:,zind], self.z_c[:,:,zind], \
                                 facecolors=cmap.to_rgba(var[:,:,zind]), linewidth=0)

        fig.colorbar(cmap)
        plt.show()
    
    
    def cubeShowSlider(self, cube, axis=2, **kwargs):
        """
        Display a 3d ndarray with a slider to move along the third dimension.
    
        Extra keyword arguments are passed to imshow.
        """
        
        from matplotlib.widgets import Slider, Button, RadioButtons
        
        # Check number of dimensions is correct.
        if not cube.ndim == 3:
            raise ValueError("cube should be an ndarray with ndim == 3")
        
        # Generate figure.
        
        fig = plt.figure()
        ax = plt.subplot(111)
        fig.subplots_adjust(left=0.25, bottom=0.25)
    
        # Select first image.
        
        s = [slice(0, 1) if i == axis else slice(None) for i in xrange(3)]
        im = cube[s].squeeze().transpose()
    
        # Display image.
        l = ax.imshow(im, **kwargs)
    
        # Define slider.
        
        axcolor = 'lightgoldenrodyellow'
        ax = fig.add_axes([0.25, 0.1, 0.65, 0.03], axisbg=axcolor)
    
        slider = Slider(ax, 'Axis %i index' % axis, 0, cube.shape[axis] - 1,
                        valinit=0, valfmt='%i')
    
        def update(val):
            ind = int(slider.val)
            s = [slice(ind, ind + 1) if i == axis else slice(None)
                     for i in xrange(3)]
            im = cube[s].squeeze()
            l.set_data(im)
            fig.canvas.draw()
    
        slider.on_changed(update)
    
        plt.show()


BaseReader.register(WchrAsciiReader)

if __name__ == '__main__':
    print 'Subclass:', issubclass(WchrAsciiReader, BaseReader)
    print 'Instance:', isinstance(WchrAsciiReader("../tests/test_data_wchr_ascii/WCHR_"), BaseReader)
